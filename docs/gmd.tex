\documentclass[12pt]{report}
\usepackage{ifthen}
\usepackage{nomenclature}
\usepackage{url}
\usepackage{calc}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{fancyvrb}
\usepackage{xcolor}
\usepackage{adjustbox}
\usepackage{changepage}
\usepackage{verbatim}
\usepackage{fancybox}
%\setlength{\parskip}{\baselineskip}%
\setlength{\parindent}{0pt}%
\definecolor{shadecolor}{rgb}{.9, .9, .9}
\definecolor{yelgr}{RGB}{154, 205, 50}
\definecolor{lemon}{RGB}{255, 215, 0}
\definecolor{cmdcol}{RGB}{32, 178, 170}

\newenvironment{example}%
   {\par\noindent\adjustbox{margin=1ex,bgcolor=shadecolor,margin=0ex
       \medskipamount}\bgroup\minipage\textwidth\verbatim}%
   {\endverbatim\endminipage\egroup}
\newenvironment{inpusage}%
   {\par\noindent\adjustbox{margin=1ex,bgcolor=lemon,margin=0ex
       \medskipamount}\bgroup\minipage\textwidth\verbatim}%
   {\endverbatim\endminipage\egroup}
\newenvironment{interface}%
   {\par\noindent\adjustbox{margin=1ex,bgcolor=lemon,margin=0ex
       \medskipamount}\bgroup\minipage\textwidth}%
   {\endminipage\egroup}
\newcommand{\param}[2]{\texttt{#1}%
  \begin{adjustwidth}{2.5em}{0pt}#2\end{adjustwidth}}
\newcommand{\usage}[1]{\indent\hspace{2.5em}\texttt{#1}}

\newcommand{\gmd}{\texttt{gmd}}
\newcommand{\gmdviz}{\texttt{gmdviz}}
\newcommand{\bldm}{\texttt{buildmtls}}
\newcommand{\exodusii}{{\sc\texttt{ExodusII}}}
\newcommand{\fpy}[1]{\texttt{f2py}}
\newcommand{\paraview}[1]{{\sc\texttt{paraview}}}
\newcommand{\pprepro}[1]{{\texttt{pprepro}}}
\newcommand{\us}{\underline{  }}
\newcommand{\uus}{\us\us{}}
\newcommand{\sol}{\texttt{solid}}
\newcommand{\eos}{\texttt{eos}}
\newcommand{\wf}{\Tensor{w}{}{}}

% --- xml
\renewcommand{\tag}[1]{\texttt{<#1>}}
\newcommand{\reqdtag}[1]{\Red{\texttt{<#1>}}}
\newcommand{\gat}[1]{\texttt{<\textbackslash{}#1>}}
\newcommand{\supporting}[1]{\texttt{Supporting Drivers: #1}}
\newcommand{\element}[4][0in]{%
  \indent\hspace{#1}\tag{#2 #3}\\%
  \indent\hspace{.2in}#4\\%
  \indent\hspace{#1}\gat{#2}}
\newcommand{\attr}[4]{%
  \ifthenelse{\equal{#3}{}}{%
    \ifthenelse{\equal{#4}{}}{%
      \texttt{#1="#2"}}{%
      \texttt{#1="#2\{#4\}"}}}{%
    \ifthenelse{\equal{#4}{}}{%
      \texttt{#1="#2[#3]"}}{%
      \texttt{#1="#2[#3]\{#4\}"}}}}


\title{\gmd{} \\ a General Material Model Driver}
\author{Tim Fuller}

\begin{document}
\maketitle

% ----------------------------------------------------------------------------- %
\chapter{Introduction to \gmd}
\gmd{} is a \textbf{G}eneral \textbf{M}aterial model \textbf{D}river designed
for rapid development and testing of material models. \gmd{} can be thought to
drive a single material point of a finite element simulation through very
specific user designed paths. This permits exercising material models in ways
not possible in finite element calculations, desgining verification and
validation tests of the material response, among others. \gmd{} is a small
tool at the developers disposal to aid in the design and implementation of
material models in larger finite element host codes. \gmd{} is the successor
the \texttt{payette} material model \cite{payette} which was itself based in
part on Tom Pucick's \texttt{MMD} \cite{pucick} and Rebecca Brannon's
\texttt{MED} \cite{brandriver} drivers.

The core of the \gmd{} code base is written in Python and leverages Python's
object oriented programming (OOP) design. OOP techniques are used throughout
\gmd{} to setup and manage simulation data. Computationally heavy portions of
the code, and the material models themselves are written in Fortran for its
speed and ubiquity in scientific computing. Calling Fortran procedures from
Python is made possible by the \fpy{} module, standard in Numpy, that compiles
and creates Python shared object libraries from Fortran sources.

Output files from \gmd{} simulations are in the \exodusii{} \cite{exodus}
database format, devloped at Sandia National Labs for storing finite element
simulation data. Since \gmd{} is designed to be used by material model
developers, it is expected that the typical user will want access to
\emph{all} all available output from a material model, thus all simulation
data is written to the output database. \exodusii{} database files can be post
processed via the \gmdviz{} utility, in addition to other visualization
packages such as \paraview{} \cite{paraview}.

\gmd{} is free software released under the MIT License.

% ----------------------------------------------------------------------------- %
\section{Why a Single Element Driver?}
Due to their complexity, it is often over kill to use a finite element code
for constitutive model development. In addition, features such as artificial
viscosity can mask the actual material response from constitutive model
development. Single element drivers allow the constituive model developer to
concentrate on model development and not the finite element response. Other
advantages of the \gmd{} (or, more generally, of any stand-alone
constitutive model driver) are

\begin{itemize}
  \item \gmd{} is a very small, special purpose, code. Thus, maintaining and
  adding new features to \gmd{} is very easy.

  \item Simulations are not affected by irrelevant artifacts such as
  artificial viscosity or uncertainty in the handling of boundary conditions.

  \item It is straightforward to produce supplemental output for deep analysis
  of the results that would otherwise constitute an unnecessary overhead in a
  finite element code.

  \item Specific material benchmarks may be developed and automatically run
  quickly any time the model is changed.

  \item Specific features of a material model may be exercised easily by the
  model developer by prescribing strains, strain rates, stresses, stress
  rates, and deformation gradients as functions of time.
\end{itemize}

% ----------------------------------------------------------------------------- %
\section{Why Python?}
Python is an interpreted, high level object oriented language. It allows for
writing programs rapidly and, because it is an interpreted language, does not
require a compiling step. While this might make programs written in python
slower than those written in a compiled language, modern packages and
computers make the speed up difference between python and a compiled language
for single element problems almost insignificant.

For numeric computations, the NumPy and SciPy modules allow programs written
in Python to leverage a large set of numerical routines provided by LAPACK,
BLASPACK, EIGPACK, etc. Python's APIs also allow for calling subroutines
written in C or Fortran (in addition to a number of other languages), a
prerequisite for model development as most legacy material models are written
in Fortran. In fact, most modern material models are still written in Fortran
to this day.

Python's object oriented nature allows for rapid installation of new material
models.

% ----------------------------------------------------------------------------- %
\section{Obtaining \gmd{}}
\gmd{} is an open source project licensed under the MIT license. A copy of may
be obtained from \url{https://github.com/tjfulle/gmd}

% ----------------------------------------------------------------------------- %
\section{About This Guide}
\gmd{} is developed as a tool for developers and analysts who care to
understand the responses of material models to specific deformation paths. The
target audience is assumed to have a basic knowledge of continuum mechanics
and familiarity with other finite element codes.  This guide provides what
would more aptly be considered an API reference manual.

% ----------------------------------------------------------------------------- %
\chapter{\gmd{} Quick Start Guide}
This guide provides an outline for building and running \gmd.

\textbf{Build \gmd{}} See Chapter \ref{chap:build}.
\begin{itemize}
  \item Download \gmd{} and setup environment
  \item \$ \verb|cd $GMDROOT/toolset && ./setup.py|
  \item \$ \texttt{buildmtls}
\end{itemize}

\textbf{Prepare Input} Inputs are xml specification files. See Chapter
\ref{chap:input}.
\begin{itemize}
  \item Set up the desired simulation path.
  \item Add material model.
  \item Add desired extraction requests.
\end{itemize}

\textbf{Run}
\begin{itemize}
  \item \$ \gmd{} [options] \emph{runid} [,\emph{runid\_1}, $\ldots$,
  \emph{runid\_n}]\\
  \emph{runid} is prefix of ``.xml'' file.
  \item Complete list of options given by \\ \$ \texttt{gmd -h}
\end{itemize}

\textbf{Postprocess}
\begin{itemize}
  \item \$ \gmdviz{} \emph{runid} [,\emph{runid\_1}, $\ldots$,
  \emph{runid\_n}]
  \item \paraview{} also reads exodus files.
\end{itemize}


% ----------------------------------------------------------------------------- %
\chapter{Building \gmd{}}
\label{chap:build}
\gmd{}'s code base is largely written in Python and requires no additional
compiling.  However, the \exodusii{} third party library and material models
written in fortran must be built.

% ----------------------------------------------------------------------------- %
\section{System and Software Requirements}
\gmd{} has been built and tested extensively on several versions of linux and
the Apple Mac OSX operating systems. It is unknown whether or not \gmd{}
will run on Windows.

\gmd{} requires the following software installed for your platform:

\begin{itemize}
  \item Python 2.7
  \item NumPy 1.6
  \item SciPy 0.10
  \item A fortran compiler
\end{itemize}

The required software may be obtained in several ways, though all development
has been made using Enthought Canopy (\url{http://http://www.enthought.com}).

A note on the fortran compiler.  It is recommended to use the same fortran
compiler to build the \gmd{} components that was used to build SciPy.

% ----------------------------------------------------------------------------- %
\section{Installation}
Ensure that all \gmd{} prerequisites are installed and working properly before
proceeding.

% ----------------------------------------------------------------------------- %
\subsection{Set Environment and Path}

\begin{description}[leftmargin=!,labelwidth=\widthof{\texttt{GMDTESTS}}]
  \item[\texttt{GMDROOT}] Optional, name of installation directory
  \item[\texttt{PATH}] \verb|$GMDROOT/toolset:$PATH|
  \item[\texttt{GMDMTLS}] ``:'' separated list of paths to directories
  containing user defined material models. See Section \ref{sec:usrbld}.
  \item[\texttt{GMDTESTS}] ``:'' separated list of paths to directories
  containing user defined regression tests. See Section \ref{sec:usrtests}.
\end{description}

% ----------------------------------------------------------------------------- %
\subsection{Set Up}
Set up and build the TPLs.
%
\begin{verbatim}
$ cd $GMDROOT/toolset
$ python setup.py
\end{verbatim}
%
In addition to building the TPLs, \texttt{setup.py} generates the following
executable scripts
%
\begin{description}[leftmargin=!,labelwidth=\widthof{\texttt{buildmtls}}]
  \item[\texttt{buildmtls}] Build material models
  \item[\texttt{gmd}] Run \gmd{} simulations
  \item[\texttt{gmddump}] Read a \gmd{} output and dumps requested variables
  to ascii columnar files
  \item[\texttt{gmdviz}] 2D plots of \gmd{} output
  \item[\texttt{runtests}] Run the regression tests
\end{description}
%
Each script is a wrapper to another \gmd{} Python file. In the wrapper,
relevant environment variables are set (e.g., \verb|$PYTHONPATH|) and the
correct Python executable (the one used to set up) is used to interpret the
\gmd{} source file.  The full set of options for each script is obtained by
%
\begin{verbatim}
$ scriptname -h
\end{verbatim}
%
where \texttt{scriptname} is the name of the script.

The TPLs will build the first time \gmd{} is setup.
Thereafter after, only the executable scripts are rewritten.  Execute

\begin{verbatim}
$ python setup.py -h
\end{verbatim}
for options to rebuild the TPLs.

% ----------------------------------------------------------------------------- %
\subsection{Build}
Build the material libraries
\begin{verbatim}
$ buildmtls
\end{verbatim}

% ----------------------------------------------------------------------------- %
\subsection{Test the Installation}
To test \gmd{} after installation, execute

\begin{verbatim}
$ runtests [-j N]
\end{verbatim}
%
which will run the \gmd{} regression tests.

% ----------------------------------------------------------------------------- %
\subsection{Troubleshooting}
If you experience problems when building/installing/testing \gmd{}, you can
ask help from the \gmd{} developers. Please include the following information
in your message:

\begin{itemize}
  \item Platform information OS, its distribution name and version information
  etc.
\begin{verbatim}
$ python -c "import os,sys;print os.name,sys.platform"
$ uname -a
\end{verbatim}

  \item Information about C,C++,Fortran compilers/linkers as reported by the
  compilers when requesting their version information, e.g., the output of
\begin{verbatim}
$ gcc -v
$ gfortran --version
\end{verbatim}

  \item Python version
\begin{verbatim}
$ python -c "import sys;print sys.version"
\end{verbatim}

\item NumPy version
\begin{verbatim}
$ python -c "import numpy;print numpy.__version__"
\end{verbatim}

\item SciPy version
\begin{verbatim}
$ python -c "import scipy;print scipy.__version__"
\end{verbatim}

\item Feel free to add any other relevant information.
\end{itemize}

% ----------------------------------------------------------------------------- %
\chapter{\gmd{} Solution Method}
\gmd{} exercises a material model directly by ``driving'' it through user
specified paths using a designated driver. Currently installed drivers are the
\sol{} and \eos{} drivers. For each driver type, \gmd{} computes an increment
in deformation for a given step and requires that the material model update
the stress in the material to the end of that step, given the current state
and an increment in deformation. Because of the similarity of the material
model interface in \gmd{} with many commercial finite element codes,
transitioning material models developed and tested in \gmd{} to full finite
element codes should be an easy process. In this chapter, the role and
importance of the material model in a finite element procedure is reviewed.
The solution method adopted by each driver in \gmd{} is then described and
compared with that of finite elements.

% ----------------------------------------------------------------------------- %
\section{The Role of the Material Model}
Conservation of mass, momentum, and energy are the central tenets of the
analysis of the response of a continuous media to deformation and/or load.
Each conservation law can be summarized by the following statement

\begin{minipage}{\textwidth}
\begin{center}
  \fbox{\begin{Bcenter}Time rate of\\ change of\\ quantity\end{Bcenter}} =
  \fbox{\begin{Bcenter}Rate of\\ production\\ in the\\ interior\end{Bcenter}} +
  \fbox{\begin{Bcenter}Flux\\ through the\\ boundary\end{Bcenter}}
\end{center}
\end{minipage}

Mathematically, the conservation laws for a point in the continuum are
%
\begin{itemize}
  \item Conservation of mass
  \begin{displaymath}
    \dDensity + \Density\Del\DotProd\dDisplacement = 0
  \end{displaymath}

  \item Conservtion of momentum per unit volume
  \begin{displaymath}
    \Density\Der{}{t}\dDisplacement =
    \underset{\text{internal forces}}{\boxed{\Del\DotProd\Stress}} +
    \underset{\text{body forces}}{\boxed{\BodyForce}}
  \end{displaymath}

  \item Conservation of energy per unit volume
  \begin{displaymath}
    \Density\Der{}{t}\Energy =
    \underset{\text{heat source}}{\boxed{\Density s}} +
    \underset{\text{strain energy}}{\boxed{\Stress\DDotProd\dStrain}} +
    \underset{\text{heat flux}}{\boxed{\Del\DotProd\HeatFlux}}
  \end{displaymath}
\end{itemize}
%
where $\Displacement$ is the displacement, $\Density$ the mass density,
$\Stress$ the stress, $\dStrain$ the rate of strain, $\BodyForce$ the body
force per unit volume, $\HeatFlux$ the heat flux, $s$ the heat source, and
$\Energy$ is the internal energy per unit mass.

In solid mechanics, mass is conserved trivially, and many problems are
adiabatic or isotrhermal, so that only the momentum balance is explicitly
solved
\begin{equation}
  \label{eq:mbal}
  \Density\Der{}{t}\dDisplacement =
  \underset{\text{internal forces}}{\boxed{\Del\DotProd\Stress}} +
  \underset{\text{body forces}}{\boxed{\BodyForce}}
\end{equation}

The balance of linear momentum is the continuum mechanics generalization of
Newton's second law $F=ma$.

The first term on the RHS of \eqref{eq:mbal} represents the internal
forces, which arise in the medium to resist imposed deformation. This
resistance is a fundamental response of matter and is given by the divergence
of the stress field.

The balance of linear momentum represents an initial boundary value problem
for applications of interest in solid dynamics:

\begin{equation}
  \label{eq:ibvp}
  \begin{aligned}
    \Density\Der{}{t}\dDisplacement = \Del\DotProd\Stress + \BodyForce&
    &&\quad\text{in }\Omega \\
    \Displacement = \Displacement_0& &&\quad\text{on }\Gamma_0 \\
    \Stress\DotProd\normal = \Traction& &&\quad\text{on }\Gamma_t \\
    \dDisplacement\left(\position, 0\right) =
    \dDisplacement_0\left(\position\right)&
    &&\quad\text{on }\position\in\Omega
  \end{aligned}
\end{equation}

This form of the momentum equation is termed the \textbf{strong} form. The
strong form of the initial BVP problem can also be expressed in the weak form
by introducing a test function $\wf$ and integrating over space
\begin{equation}
  \label{eq:ibvp-1}
  \begin{aligned}
    \int_{\Omega}\wf\left(
      \Del\DotProd\Stress + \BodyForce - \Density\Der{}{t}\dDisplacement
    \right)\,d\Omega& &&\quad \forall \wf \\
    \Displacement = \Displacement_0& &&\quad\text{on }\Gamma_0 \\
    \Stress\DotProd\normal = \Traction& &&\quad\text{on }\Gamma_t \\
    \dDisplacement\left(\position, 0\right) =
    \dDisplacement_0\left(\position\right)&
    &&\quad\text{on }\position\in\Omega
  \end{aligned}
\end{equation}

Integrating \eqref{eq:ibvp-1} by parts allows the traction boundary conditions
to be incorporated in to the governing equations
\begin{equation}
  \label{eq:weak}
  \begin{aligned}
    \int_{\Omega}\Density\wf\DotProd\Acceleration +
    \Stress\DDotProd\Del\wf\,d\Omega
    = \int_{\Omega}\wf\DotProd\BodyForce\,d\Omega +
    \int_{\Gamma}\wf\DotProd\Traction\,d\Gamma_{t}& &&\forall \wf \\
    %
    \Displacement = \Displacement_0& &&\quad\text{on }\Gamma_0 \\
    \dDisplacement\left(\position, 0\right) =
    \dDisplacement_0\left(\position\right)&
    &&\quad\text{on }\position\in\Omega
  \end{aligned}
\end{equation}

This form of the IBVP is called the \textbf{weak} form.  The weak form
poses the IBVP as a integro-differential equation and eliminates singularities
that may arise in the strong form.  Traction boundary conditions are
incorporated in the governing equations.  The weak form forms the basis for
finite element methods.

In the finite element method, forms of $\wf$ are assumed in subdomains
(elements) in $\Omega$ and displacements are sought such that the force
imbalance $R$ is minimized:

\begin{equation}
  \label{eq:resid}
  R = \int_{\Omega}\wf\DotProd\BodyForce\,d\Omega +
  \int_{\Gamma}\wf\DotProd\Traction\,d\Gamma_{t} -
 \int_{\Omega}\Density\wf\DotProd\Acceleration + \Stress\DDotProd\Del\wf\,d\Omega
\end{equation}

The equations of motion as described in \eqref{eq:resid} are not closed, but
require relationships relating $\Stress$ to $\Displacement$

\begin{center}
  \fbox{Constitutive model $\longrightarrow$ relationship between $\Stress$
    and $\Displacement$}
\end{center}


% ----------------------------------------------------------------------------- %
\section{Solid Driver}
As the name implies, the \sol{} driver is designed to exercise the type of
material models encountered in solid mechanics. The solution method is similar
to that of many finite element codes, so that material models developed and
tested in \gmd{} can be easily transitioned to them.

\begin{equation}
  \label{eq:solid-0}
  \Stress = f\left[\Stress, \ISV, \dStrain\right]
\end{equation}
%
where $\Stress$ is the stress state, $\ISV$ are a set of path dependent
internal state variables, and $\dStrain$ is the strain rate. The definitions
of $\Stress$ and $\dStrain$ are left intentionally vague, except that the pair
is work conjugate.  Further explanation of $\Stress$ and $\dStrain$ are
deferred until a later section.  Users drive the material through specified
deformation paths.  The path can also be a specified stress, in which case we
solve for $\dStrain$ to be
%
\begin{equation}
  \label{eq:inv-prob-0}
  \dStrain = \dStrain_0 + f^{-1}\left[\Stress, \ISV,
    \dStrain\right]\left(\Stress - \Stress_0\right)
\end{equation}

Mixed modes are also allowed.  Paths can be prescribed by specifying the
components of strain and their rates, components of deformation gradient,
displacements of boundary of unit cube, components of stress and their rates.
Mixed modes involving strains and stresses allowed.

% ----------------------------------------------------------------------------- %
\subsection{Electrical}
Electric field can be prescribed for testing piezoelectric models.

% ----------------------------------------------------------------------------- %
\chapter{Running}

\begin{verbatim}
$ gmd runid[.xml]
\end{verbatim}

The following files will be produced
\begin{verbatim}
$ ls runid.*
runid.exo       runid.log       runid.xml
\end{verbatim}

\texttt{runid.exo} is the \exodusii{} output database, \texttt{runid.log} the log
file, and \texttt{runid.xml} the input file.


% ----------------------------------------------------------------------------- %
\chapter{User Input: Overview}
User input is via xml control files. In general, tags use CamelCase and
attributes lower case.  Attributes are described in this document as
%
\begin{verbatim}
attr="type[default]{choices}"
\end{verbatim}
%
where \texttt{default} is the default value (if any) and \texttt{\{choices\}}
are valid choices (if any). Any attribute not having a default value is
required. Types are \texttt{str}, \texttt{int}, \texttt{real}, \texttt{list}.
Lists are given as space separated lists (e.g., "1 2 3").

In the following, elements shown in \Red{red} are required input.

% ----------------------------------------------------------------------------- %
\section{GMDSpec}
All input files must have as their root element \reqdtag{GMDSpec}.
\begin{inpusage}
<GMDSpec>
\end{inpusage}

Recognized subelements of \reqdtag{GMDSpec} are
%
\begin{itemize}
  \item \reqdtag{Physics}
  \item \tag{Permutation}
  \item \tag{Optimization}
\end{itemize}

The following elements are read from any scope in the input file
%
\begin{itemize}
  \item \tag{Include}
  \item \tag{Function}
\end{itemize}

The \reqdtag{Physics}, \tag{Permutation}, \tag{Optimization} and input blocks
are described separately in their own chapters.

% ----------------------------------------------------------------------------- %
\section{Preprocessing}
Preprocessing allows specifying variables in the input inside of comment tags
for use in other parts of the input. Syntax mirrors that of \texttt{aprepro}.
Preprocessor also evaluates (nearly) any Python expression.

The \texttt{random()} expression generates a random number. The
\verb|random_seed| variable sets the random state seed. Note, expressions are
evaluated in order, therefore, if setting the \verb|random_seed| it should
occur early.

The following input stub demonstrates specifying the \reqdtag{Material}
parameter \texttt{K} and \texttt{G}, and \tag{Path} parameter \texttt{estar}
as variables
\begin{example}
<GMDSpec>
  <!-- {random_seed = 7}
       {G = 54e9 * random()}
       {K = 23e9}
       {estar = -.05}
  -->
  <Physics>
    <Material model="elastic">
      <K> {K} </K>
      <G> {G} </G>
    </Material>
    <Path type="prdef" estar="{estar}">
      ...
    </Path>
  </Physics>
</GMDSpec>
\end{example}

% ----------------------------------------------------------------------------- %
\section{Include}
Path to file to be included as if its contents were inplace in the input file

\begin{inpusage}
<Include href="str"/>
\end{inpusage}

The following stub input demonstrates how to include a file in place
\begin{example}
<Include href="/path/to/some/file.ext"/>
\end{example}

% ----------------------------------------------------------------------------- %
\section{Function}
Define functions to be used elsewhere in input. \texttt{id=0} and
\texttt{id=1} are reserved for the constant $0$ and $1$ functions,
respectively. \texttt{href} is the path to a file containing the function
definition (useful when the function is a large piecewise linear table).
\texttt{cols} specifies the columns in which data is located in a piecewise
linear table.

\begin{inpusage}
<Function id="int"
          type="str{analytic_expression, piecewise_linear}"
          var="str[x]" href="str[]" cols="list[1 2]">
\end{inpusage}

The following input stub demonstrates how to define an analytic expression and
piecewise linear table as functions

\begin{example}
<Function id="2" type="analytic_expression" var="t">
  sin(t)
</Function>
<Function id="3" type="piecewise_linear">
  1 2
  2 3
  3 5
</Function>

<!-- Read a piecewise linear table from an external file using
     columns 1 and 3
-->
<Function id="4" type="piecewise_linear" href="./file.dat"
          cols="1 3"/>
\end{example}

\begin{verbatim}
$ cat file.dat
# Column1 Column2 Column3
1 1 4
2 3 7
.
.
.
100 4.2 1.43
\end{verbatim}

% ----------------------------------------------------------------------------- %
\chapter{User Input: Physics}
\label{chap:input}
Define the physics of the simulation. If specified, \verb:termination_time:
defines the termination time for the simulation. If not specified, termination
time is taken as final time in \reqdtag{Path}.

\begin{inpusage}
<Physics driver="str[solid]{solid, eos}"
         termination_time="real[]">
\end{inpusage}

Recognized subelements of \reqdtag{Physics} are
%
%
\begin{itemize}
  \item \reqdtag{Path}
  \item \reqdtag{Material}
  \item \tag{Extract}
\end{itemize}

% ----------------------------------------------------------------------------- %
\section{Path}
Define deformation paths through with the material will be exercised.

\begin{inpusage}
<Path type="str{prdef, surface}"
      format="str[default]{default, table, fcnspec}"
      cols="list[1, ..., n]" cfmt="str"
      tfmt="str[time]{time,dt}"
      nfac="int[1]" kappa="real[0]" rstar="real[1]"
      tstar="real[1]" estar="real[1]" sstar="real[1]"
      amplitude="real[1]" ratfac="real[1]" href="str">
\end{inpusage}

% ----------------------------------------------------------------------------- %
\subsection{Path Attributes}

% ----------------------------------------------------------------------------- %
\subsubsection{type}
The type of path specified.  Valid types are \texttt{prdef} and
\texttt{surface}.

The \texttt{prdef} type defines a prescribed deformation. The jth leg of
\reqdtag{Path} is sent to the driver in form \texttt{[tf, n, cfmt, Cij]},
where \texttt{tf}, \texttt{n}, \texttt{cfmt}, and \texttt{Cij} are the
termination time, number of steps, control format, and control values. Methods
of inputing legs depends on the attributes of \reqdtag{Path} and will be shown
in examples to follow.

The \texttt{surface} input is similar to the \texttt{prdef} specification, but
leg termination time is not specified. Control parameters also differ, as
shown in Table \ref{tab:cfmt-1}.

% ----------------------------------------------------------------------------- %
\subsubsection{Format}
The format by which the legs of the deformation path are specified. Valid
formats are \texttt{default}, \texttt{table}, and \texttt{fcnspec}. In the
following subsections, the different formats are described.

% ----------------------------------------------------------------------------- %
\paragraph{Format: default}
\label{sec:defform}
The \texttt{default} format offers the most control.  In this format, the
termination time, number of steps, control format, and components of
deformation are specified for each leg as in the following stub input

\begin{example}
<Path type="default">
  <!-- tterm nsteps cfmt c1 c2 c3 ... -->
  0  0 222222 0 0 0 0 0 0
  1 10 222222 1 0 0 0 0 0
</Path>
\end{example}

See Section \ref{sec:cfmt} for a full description of the control format
\texttt{cfmt} and its relationship with the \texttt{c1, c2, c3, ...}.


% ----------------------------------------------------------------------------- %
\paragraph{Format: table}
\label{sec:tblform}
The \texttt{table} format allows reading in deformation paths from a columnar
table of data. Control format is uniform for all legs. Specify control format
as \texttt{cfmt} attribute of \reqdtag{Path}. Specify which columns to read
data with the \texttt{cols} attribute. The first column is assumed to be the
time specifier. See Section \ref{sec:colspec} for a description of the
\texttt{cols} attribute. The \texttt{tfmt} attribute specifies if the time
column represents the actual time (\verb|tfmt="time"|) or time step
(\texttt{tmft="dt"}). The number of steps for each leg can be set by
\texttt{nfac}. The \texttt{href} attribute specifies an external file to read
the table.

The following input stubs demonstrate reading a table from the input file and
from an external file.

\begin{example}
<!-- Read entries from table. -->
<Path type="prdef" format="table" cols="1:4" cfmt="222"
      tfmt="time">
  0 0 0 0
  1 1 0 0
    ...
  n 2 0 0
</Path>
\end{example}

\begin{example}
<!-- Read table from external file -->
<Path type="prdef" format="table" cols="1 3:8" cfmt="222222"
      tfmt="time" href="exmpls.tbl"/>
\end{example}

% ----------------------------------------------------------------------------- %
\paragraph{Format: fcnspec}
\label{sec:tblform}
The \texttt{fcnspec} format allows defining a deformation path by a function.
A deformation path defined by \texttt{fcnspec} must have only 1 leg defining
the termination time and the function specifier defining the values of the
components of deformation.  The function specifier is of the form

\begin{example}
function_id[:scale]
\end{example}

where \texttt{function\us{}id} is the ID of the function as specified in its
\tag{Function} element.  The optional scale is multiplied by the function.

The following input stub demonstrates uniaxial strain deformation, using a
user defined function to specify the 11 component of strain through time.

\begin{example}
<Path type="prdef" format="fcnspec" cfmt="222" nfac="200">
  <!-- termination time, fcn spec -->
  {2 * pi} 2:1.e-1 0 0
</Path>
\end{example}

\subsubsection{Control Format}
\label{sec:cfmt}
The control format \texttt{cfmt} is concatenated integer list specifying in
its $i^\text{ith}$ component the $i^\text{th}$ component of deformation, i.e.,
\texttt{cfmt[i]} instructs the driver as to the type of deformation
represented by \texttt{Cij[i]}. Types of deformation represented by
\texttt{cfmt} are shown in Table \ref{tab:cfmt}.

For example, the following \texttt{cfmt} instructs the driver that the
components of \texttt{Cij} represent [stress, strain, stress rate, strain
rate, strain, strain], respectively:

\begin{example}
cfmt="423122"
\end{example}

Mixed modes are allowed only for components of strain rate, strain, stress
rate, and stress. Electric field components can be included with any
deformation type.

The components \texttt{Cij} take the following order

\paragraph{Vectors:} [X, Y, Z]

\paragraph{Symmetric tensors:} [XX, YY, ZZ, XY, YZ, XZ]

\paragraph{Tensors:} [XX, XY, XZ, YX, YY, YZ ZX, ZY, ZZ]

If \texttt{len(Cij) $\neq$ 6} (or 9 for deformation gradient), the missing
components are assumed to be zero strain.

\begin{table}[h!]
  \centering
  \begin{tabular}[h]{cl}
    \hline
    \hline
    \texttt{cfmt} & Deformation type \\
    \hline
    1 & Strain rate \\
    2 & Strain \\
    3 & Stress rate \\
    4 & Stress \\
    5 & Deformation gradient \\
    6 & Electric field
  \end{tabular}
  \caption{Supported deformation types and \texttt{cfmt} code for
    \texttt{solid} \texttt{prdef} paths}
  \label{tab:cfmt}
\end{table}

\begin{table}[h!]
  \centering
  \begin{tabular}[h]{cl}
    \hline
    \hline
    \texttt{cfmt} & Variable type \\
    \hline
    1 & Density \\
    2 & Temperature
  \end{tabular}
  \caption{Supported surface variable types and \texttt{cfmt} code for
    \texttt{eos} \texttt{surface} paths}
  \label{tab:cfmt-1}
\end{table}

% ----------------------------------------------------------------------------- %
\subsubsection{Time Format}
The \texttt{tfmt=["time"]\{"time","dt"\}} flag specifies the time format.
If \texttt{tfmt="time"} (default) the first value of each leg is interpreted
as the termination time for the leg. For \texttt{tfmt="dt"} the first value
of each leg is interpreted as a time increment.

% ----------------------------------------------------------------------------- %
\subsubsection{kappa}
\label{sec:kappa}
The attribute \texttt{kappa} is only used/defined for the purposes of strain
or strain rate control. It refers to the coefficient used in the Seth-Hill
generalized strain definition
%
\begin{equation}
  \Strain = \frac{1}{\kappa}\left(\RightStretch^\kappa - \SOIdentity\right)
\end{equation}
%
where $\kappa$ is the keyword \texttt{kappa}, $\Strain$ is the strain tensor,
$\RightStretch$ is the right Cauchy stretch tensor, and $\SOIdentity$ is the
second order identity tensor. Common values of $\kappa$ and the associated
common names for each (there is some ambiguity in the names) are:

\begin{table}[h]
  \centering
  \begin{tabular}{ll}
    \hline
    $\kappa$ &  Name(s) \\
    \hline
    -2 & Green \\
    -1 & True, Cauchy \\
     0 & Logarithmic, Hencky, True \\
     1 & Engineering, Swainger \\
     2 & Lagrange, Almansi \\
     \hline
  \end{tabular}
\end{table}

% ----------------------------------------------------------------------------- %
\subsubsection{The Column Specifier}
\label{sec:colspec}
The columns to read from a table or the \texttt{fcnspec} leg are specified by
the \texttt{cols} attribute.  \texttt{cols} are specified as a space separated
list of columns.  Numbering is 1 based.  Ranges can be specified using Python
slice syntax.

The following input stubs demonstrate two equivalent ways to to read columns
1, 3, 4, 5, 8, 9, and 13 from a table.
\begin{example}
cols="1 3 4 5 8 9 13"
\end{example}

\begin{example}
cols="1 3:5 8:9 13"
\end{example}

% ----------------------------------------------------------------------------- %
\subsubsection{Step Multiplier}
\texttt{nfac} is a multiplier on the number of steps for each leg.

% ----------------------------------------------------------------------------- %
\subsubsection{Amplitude}
\texttt{amplitude} is a factor multiplied to all components of deformation.

% ----------------------------------------------------------------------------- %
\subsubsection{The ``star'' Multipliers}
\label{sec:stars}
\texttt{[rtes(ef)]star} are multipliers on the components of density, time
(temperature for \texttt{type="surface"}), strain, stress, and electric field,
respectively. The \texttt{[rtes(ef)]star} are first multiplied by
\texttt{amplitude}.

% ----------------------------------------------------------------------------- %
\subsubsection{Rate Factor}
\label{sec:ratfac}
\texttt{ratfac} is a divisor to the termination time of each leg, thereby
effectively increasing the rate of deformation.

% ----------------------------------------------------------------------------- %
\subsection{More Examples}
The following examples will help clarify the \reqdtag{Path} input syntax

\begin{example}
<!-- uniaxial strain, all six components of strain
     prescribed -->
<Path type="prdef" kappa="0" tstar="1" estar="-.5"
      amplitude="1" ratfac="1">
  <!-- termination time, number of steps, cfmt, Cij -->
  0   0 222222 0 0 0 0 0 0
  1 100 222222 1 0 0 0 0 0
  2 100 222222 2 0 0 0 0 0
  3 100 222222 1 0 0 0 0 0
  4 100 222222 0 0 0 0 0 0
</Path>
\end{example}

\begin{example}
<!-- uniaxial strain, stress controlled -->
<Path type="prdef" nfac="100">
  0 0 444 0 0 0
  1 1 444 -7490645504 -3739707392 -3739707392
  2 1 444 -14981291008 -7479414784 -7479414784
  3 1 444 -7490645504 -3739707392 -3739707392
  4 1 444 0 0 0
</Path>
\end{example}

\begin{example}
<!-- uniaxial stress, mixed mode -->
<Path type="prdef" nfac="100">
  0 0 222 0 0 0
  1 1 244 {epsmax} 0 0
  4 1 244 0 0 0
</Path>
\end{example}

\subsubsection{Example of \texttt{type="surface"}}
The following examples demonstrate the \texttt{type="surface"}
\begin{example}
<Path type="surface">
  <!-- nsteps, control, Cij -->
  <!-- control goes as 1 -> density
                       2 -> temperature -->
    0 12 1 100
  100 12 5 300
</Path>
\end{example}

\begin{example}
<Path type="surface" format="table" cfmt="12" nfac="100">
  <!-- Cij -->
  1 100
  5 300
</Path>
\end{example}

% ----------------------------------------------------------------------------- %
\section{Material}
Define the material model.

\begin{inpusage}
<Material model="str">
\end{inpusage}

Subelements of \reqdtag{Material} are
%
\begin{itemize}
  \item \tag{Matlabel}
  \item \tag{ParameterArray}
  \item \tag{InitialState}
  \item \tag{Key}*
\end{itemize}
%
*\tag{Key} is a valid material parameter name.

% ----------------------------------------------------------------------------- %
\subsection{Material Attributes}
\subsubsection{model}
The name of the material model.

% ----------------------------------------------------------------------------- %
\subsection{Matlabel}
Insert model parameters from a database file.
\begin{inpusage}
<Matlabel href="str[F_MTL_PARAM_DB]" material="str"/>
\end{inpusage}

% ----------------------------------------------------------------------------- %
\subsubsection{Matlabel Attributes}
\paragraph{href}
The path to the database file. Defaults to\\
\verb:$GMDROOT/materials/material_properties.db: if no file is given.

% ----------------------------------------------------------------------------- %
\paragraph{material}
Name of material as given in the database file.

The following input stub demonstrates the use of \tag{Matlabel}
\begin{example}
<Material model="elastic">
  <Matlabel href="./materials.xml" material="aluminum"/>
</Material>
\end{example}

\subsection{ParameterArray}
Specify the parameter array for the material as whitespace separated list of
floats.  The list of values must be the same length as the parameter array for
the material or an error will occur.
\begin{inpusage}
<ParameterArray>
  VAL1 VAL2 ... VALN
</ParameterArray>
\end{inpusage}

% ----------------------------------------------------------------------------- %
\subsection{InitialState}
Specify the initial state of the material as a whitespace separated list of
floats. Six stress values must be followed by material variables (if any). The
length of the material variables must be the same as the length of the
\texttt{xtra} variable array for the material or an error will occur.  Note,
implementation is material model specific.
\begin{inpusage}
<InitialState>
  STRESS_XX STRESS_YY ... STRESS_XZ XTRA1 XTRA2 ... XTRAN
</InitialState>
\end{inpusage}

% ----------------------------------------------------------------------------- %
\subsection{Specify Individual Parameters}
Specify individual parameters as xml text nodes
\begin{inpusage}
<Key> float </Key>
\end{inpusage}

\tag{Key} is replaced by specific material model parameters. The following
stub inputs demonstrate the \reqdtag{Material} input
\begin{example}
<Material model="elastic">
  <G>  54E+09 </G>
  <K> 124E+09 </K>
</Material>
\end{example}

% ----------------------------------------------------------------------------- %
\section{Extract}
Extract variables and paths from \exodusii{} output and (optionally) write to
different formats.
\begin{inpusage}
<Extract format="str[ascii]{ascii, mathematica, ndarray}"
         step="int[1]" ffmt="str[.18f]">
\end{inpusage}

Recognized subelements of \tag{Extract} are
%
\begin{itemize}
  \item \tag{Path}*
  \item \tag{Variables}
\end{itemize}
%
* \texttt{eos} driver only

% ----------------------------------------------------------------------------- %
\subsection{Extract Attributes}
\subsubsection{format}
The format to write the output.  \texttt{ascii} format writes out columnar
data as an ascii text file, \texttt{mathematica} writes an ascii text file
that can be read by Mathematica, and \texttt{ndarray} writes the data to a
file in the numpy .npy binary format.

% ----------------------------------------------------------------------------- %
\subsubsection{step}
Extract every \texttt{step}th timestep.

% ----------------------------------------------------------------------------- %
\subsubsection{ffmt}
The string format used write out variables.

% ----------------------------------------------------------------------------- %
\subsection{Variables}
Variables to extract from the \exodusii{} output database. Variables are specified
children of the \tag{Variables} element. All components of vector and tensor
variables will be extracted if only the basename is specified. Time is always
extracted as the first entry of the output file.  Extracted variables are in
\texttt{runid.out} or \texttt{runid.math} depending if the format is ascii or
mathematica.
\begin{inpusage}
<Variables>
  VAR_1, ..., VAR_N
</Variables>
\end{inpusage}

The following example demonstrates how to extract all components of stress and
strain
\begin{example}
<Extract format="ascii">
  <variables>
    STRESS STRAIN
  </variables>
</Extract>
\end{example}

Extract only the XX, YY, and ZZ components of stress
\begin{example}
<Extract format="ascii">
  <variables>
    STRESS_XX STRESS_YY STRESS_ZZ
  </variables>
</Extract>
\end{example}

Extract all variables
\begin{example}
<Extract format="ascii">
  <variables>
    ALL
  </variables>
</Extract>
\end{example}

% ----------------------------------------------------------------------------- %
\subsubsection{Path}
Extract a specified path from the equation of state surface through the
specified density range starting at the initial temperature.
\begin{inpusage}
<Path type="str{isotherm, hugoniot}" increments="int[100]"
      density_range="list" initial_temperature="real">
\end{inpusage}

The following input stub demonstrates extracting Hugoniot and Isotherm paths
\begin{example}
<Extract>
  <Path type="isotherm" increments="200"
        density_range="1 3" initial_temperature="225"/>
  <Path type="hugoniot" increments="100"
        density_range="1 3" initial_temperature="100"/>
</Extract>
\end{example}

% ----------------------------------------------------------------------------- %
\chapter{User Input: Permutation}
Permutate model input parameters, running jobs with different realization of
parameters. Ideal for investigating model sensitivities.
%
\begin{inpusage}
<Permutation method="str[zip]{zip,combine,shotgun}"
                     seed="real[date]"
                     correlation="list[none]{plot,table,none}">
\end{inpusage}

Recognized subelements of \tag{Permutation} are

\begin{itemize}
  \item \reqdtag{Permutate}
  \item \tag{ResponseFunction}
\end{itemize}

Each \tag{Permutation} job creates a directory \texttt{runid.eval}
\begin{verbatim}
$ ls runid.eval
eval_0/    eval_2/    gmd-evaldb.xml
eval_1/    ...        runid.log
\end{verbatim}

The \texttt{eval\us{}i} directory holds the output of the
\texttt{i}$^{\text{th}}$ job, including \texttt{params.in} with the values of
each permutated parameter for that job. \texttt{gmd-tabular.xml} contains a
summary of each job run. \gmdviz{} recognizes \texttt{gmd-tabular.xml} files.

% ----------------------------------------------------------------------------- %
\section{Permutation Attributes}
\subsection{method}
The \texttt{method} attribute describes which method to use to determine
parameter combinations to run.

The \texttt{zip} method runs one job for each set of parameters (and, thus,
the number of realizations for each parameter must be identical), the
\texttt{combine} method runs every combination of parameters.

\subsection{correlation}
Create correlation table and plots of relating permutated parameters and value
of response function. \texttt{correlation} is only meaningful if a
\tag{ResponseFunction} is specified.

\subsection{seed}
The seed for the random number generator. \texttt{date} is todays date in
seconds.

% ----------------------------------------------------------------------------- %
\section{Permutate}
Specify the paramaters to permutate.
\begin{inpusage}
<Permutate var="str"
           values="func{range,list,weibull,uniform,
                        normal,percentage}"
\end{inpusage}

\subsection{Permutate Attributes}
\subsubsection{var}
\texttt{var} is the name of the variabe and should occur elsewhere in
the input file in preprocessing braces.

\subsubsection{values}
\texttt{values} are the specific values. The
\texttt{range,list,weibull,uniform,normal,percentage} are all specified as
functions with the following form

\begin{example}
values="func(start,stop,N)"
\end{example}

The following input stub demonstrates how to permutate the \texttt{K} and
\texttt{G} parameters
%
\begin{example}
<Permutation method="zip" seed="12">
  <Permutate var="K" values="weibull(125.e9, 14, 3)"/>
  <Permutate var="G" values="percentage(45.e9, 10, 3)"/>
</Permutation>
\end{example}

In the \tag{Material} element, the \texttt{K} and \texttt{G} parameters are
specified as
%
\begin{example}
<Material model="elastic">
  <K> {K} </K>
  <G> {G} </G>
</Material>
\end{example}

% ----------------------------------------------------------------------------- %
\section{ResponseFunction}
The \tag{ResponseFunction} returns the response from permutation or
optimization jobs.
\begin{inpusage}
<ResponseFunction href="str" function="gmdfcn"
                  descriptor="str[]"/>
\end{inpusage}

One of \texttt{href} or \texttt{function} must be specified.

% ----------------------------------------------------------------------------- %
\subsection{ResponseFunction Attributes}
\subsubsection{descriptor}
\texttt{descriptor} is the name given to the response function in the output.

% ----------------------------------------------------------------------------- %
\subsubsection{href}
\texttt{href} is the path to an executable file script containing the response
function. The script is called from the command line as

\begin{verbatim}
% ./scriptname runid.exo
\end{verbatim}

An example of a response function specifying \texttt{href} is
\begin{example}
<ResponseFunction href="./scriptname" descriptor="PRES"/>
\end{example}

% ----------------------------------------------------------------------------- %
\subsubsection{function}
\texttt{function} is the name of a builtin \gmd{} response function. Built in
response functions are
%
\begin{itemize}
  \item \texttt{gmd.max} maximum value of a simulation variable output
  \item \texttt{gmd.min} minimum value of a simulation variable output
  \item \texttt{gmd.mean} mean value of a simulation variable output
  \item \texttt{gmd.ave} average value of a simulation variable output
  \item \texttt{gmd.absmax} maximum absolute value of a simulation variable output
  \item \texttt{gmd.absmin} minimum absolute value of a simulation variable output
\end{itemize}
%
Built in response functions operate only on variabes in the simulation output file.

An example of a response function specifying \texttt{function} is
\begin{example}
<ResponseFunction function="gmd.max(PRESSURE)"
                  descriptor="PRES"/>
\end{example}

% ----------------------------------------------------------------------------- %
\chapter{User Input: Optimization}
Optimize specified parameters against user specified objective function.
%
\begin{inpusage}
<Optimization method="str[simplex]{simplex, powell, cobyla}"
              maxiter="int[25]" tolerance="real[1e-6]">
\end{inpusage}

Recognized subelements of \tag{Optimization} are

\begin{itemize}
  \item \reqdtag{Optimize}
  \item \reqdtag{ResponseFunction}
  \item \tag{AuxiliaryFile}
\end{itemize}

Like \tag{Permutation} jobs, each \tag{Optimization} job creates a directory
\texttt{runid.eval}
\begin{verbatim}
$ ls runid.eval
eval_0/    eval_2/    gmd-evaldb.xml     runid.log
eval_1/    ...        params.opt
\end{verbatim}

The \texttt{eval\us{}i} directory holds the output of the
\texttt{i}$^{\text{th}}$ job, including \texttt{params.in} with the values of
each parameter for that job. \texttt{gmd-tabular.xml} contains a
summary of each job run. \gmdviz{} recognizes \texttt{gmd-tabular.xml} files.
\texttt{params.opt} has the final, optimized, parameters.

% ----------------------------------------------------------------------------- %
\section{Optimization Attributes}
\subsection{method}
\texttt{method} specifies the optimization method.  All optimization routines
utilize the scipy.optimize module.

% ----------------------------------------------------------------------------- %
\subsection{maxiter}
\texttt{maxiter} is the maximum number of iterations.

% ----------------------------------------------------------------------------- %
\subsection{tolerance}
\texttt{tolerance} is the optimization tolerance.

% ----------------------------------------------------------------------------- %
\section{Optimize}
Specify the variable to be optimized.
\begin{inpusage}
<Optimize var="str" initial_value="real" bounds="list[]"/>
\end{inpusage}

% ----------------------------------------------------------------------------- %
\subsection{Optimize Attributes}
\subsubsection{var}
\texttt{var} is the name of the variabe and should occur elsewhere in
the input file in preprocessing braces.

% ----------------------------------------------------------------------------- %
\subsubsection{initial\us{}value}
\texttt{initial\us{}value} is the initial value of \texttt{var}

% ----------------------------------------------------------------------------- %
\subsubsection{bounds}
\texttt{bounds} specifies lower and upper bounds on \texttt{var}. Only the
\texttt{cobyla} method accepts bounds.

% ----------------------------------------------------------------------------- %
\section{AuxiliaryFile}
Path to any auxiliary file needed by the optimization objective function.
\begin{inpusage}
<AuxiliaryFile href="str"/>
\end{inpusage}

% ----------------------------------------------------------------------------- %
\section{ResponseFunction}
Same as for \tag{Permutation}, except that auxiliary files are also passed to
the function. The value returned from the response function is interpreted as
the error to be minimized.

If the \tag{ResponseFunction} is given by \texttt{href}, it is called as
\begin{verbatim}
% ./scriptname runid.exo [AuxFile1[AuxFile2[...]]]
\end{verbatim}

\section{Example}
Optimize the \texttt{K} and \texttt{G} parameters
\begin{example}
<Optimization method="simplex" maxiter="25" tolerance="1e-4">
  <ResponseFunction href="opt-sig-v-time"
                    descriptor="SIG_V_TIME"/>
  <AuxiliaryFile href="opt-baseline.dat"/>
  <Optimize var="opt_k" initial_value="129.e9"/>
  <Optimize var="opt_g" initial_value="54.e9"/>
</Optimization>
\end{example}

In the \reqdtag{Material} element, the \texttt{K} and \texttt{G} parameters
are specified as
%
\begin{example}
<Material model="elastic">
  <K> {opt_k} </K>
  <G> {opt_g} </G>
</Material>
\end{example}

% ----------------------------------------------------------------------------- %
\chapter{\gmd{} User Material Interface}
\label{chap:usrmtl}
\gmd{} can be made to find, build, and execute user materials outside of
\verb|$GMDROOT|.  User materials can be written in Python or Fortran and and
\gmd{} interacts with them through the application programming interface
(API).  In general, the following pattern is followed for exercising a
material model with \gmd{}:
%
\begin{enumerate}
  \item create a material model interface (MMI)
  \item build and link the material model to \gmd{}
  \item exercise the model
\end{enumerate}
%

% ----------------------------------------------------------------------------- %
\section{Material Model Interface}
\label{sec:usrint}
\gmd{} interacts with materials through a material interface file. The
material interface file defines the material class which must be a subclass of\\
\verb|$GMDROOT/materials._material.Material|.  In this section, methods of the
\verb|Material| class are described.

% ----------------------------------------------------------------------------- %
\subsection{Material Class Instantiation}
\label{sec:basecls}
The base class \verb|Material| in \verb|$GMDROOT/materials._material| creates
new \gmd{} materials and provides the interface with which \gmd{} interacts.
Each class must define its name (\verb|Material.name|) and an ordered list of
material parameter names (\verb|Material.param_names|) as they appear in the
input file.  The class should not define an \texttt{\uus{}init\uus{}} method
and if it does, should call the \texttt{\uus{}init\uus{}} of the base class.

\begin{interface}
  \textbf{Material: Interface}
\end{interface}
\usage{mtl = Material()}

The following is an example of a \texttt{Material} declaration for the
\texttt{Elastic} material model
%
\begin{example}
from materials._material import Material
class Elastic(Material)
    name = 'elastic'
    param_names = ['K', 'G']
\end{example}

\subsection{Setup the Material}
The method \texttt{setup} sets up the material model by checking and setting
the material parameter array, requesting allocation of storage of material
variables, and computing and storing the \verb|bulk_modulus| and
\verb|shear_modulus| of the material.

\begin{interface}
  \textbf{Material.setup: Interface}
\end{interface}
\usage{mtl.setup(params)}\\[5pt]
\param{ndarray params}{Material parameters parsed from the input file}

The following is an example of a \texttt{setup} method

\begin{example}
def setup(self, params):
    if elastic is None:
        raise Error1("elastic model not imported")
    elastic.elastic_check(params, log_error, log_message)
    K, G, = params
    self.set_param_vals(params)
    self.bulk_modulus = K
    self.shear_modulus = G
\end{example}

\subsection{Store Parameter Array with \gmd{}}
The method \verb|set_param_vals| stores the checked parameter values with
\gmd{}.  It must be called by each instance of the material model.

\begin{interface}
  \textbf{Material.set\us{}param\us{}vals: Interface}
\end{interface}
\usage{mtl.set\us{}param\us{}vals(params)}\\[5pt]
\param{ndarray params}{Checked material parameters}

The following is an example of how \verb|set_param_vals| is used within a
mterials \verb|setup| method.

\begin{example}
params = self._check_params(params)
self.set_param_val(params)
\end{example}


\subsection{Adjust the Initial State}
The method \texttt{adjust\us{}initial\us{}state} adjusts the initial state
after the material is setup. Method provided by base class should be adequate
for most materials. A material should only overide the base method if
absolutely necessary.

\begin{interface}
  \textbf{Material.adjust\us{}initial\us{}state: Interface}
\end{interface}
\usage{mtl.adjust\us{}initial\us{}state(xtra)}\\[5pt]
\param{ndarray xtra}{Material variables}

\subsection{Update the Material State}
The material state is updated to the end of the step via the
\verb|update_state| method. Each material model must provide its own
\verb|update_state| method.

\begin{interface}
  \textbf{Material.update\us{}state: Interface}
\end{interface}
\usage{stress, xtra = mtl.update\us{}state(dt, d, sig, xtra, *args)}\\[5pt]
\param{real dt}{timestep size}
\param{ndarray d}{rate of deformation}
\param{ndarray sig}{stress at beginning of step}
\param{ndarray xtra}{extra state variables at beginning of step}
\param{tuple args}{(\texttt{defgrad}, \texttt{efield}, \texttt{time},
  \texttt{rho}, \texttt{tmpr}) extra positional arguments.}
\param{dict kwargs}{extra keyword args (not used)}
\param{ndarray stress}{stress at end of step}
\param{ndarray xtra}{extra state variables at end of step}

The following code segment is used by the driver to update the material state
\begin{example}
args = (f, ef, t, None, None)
sig, xtra = mtl.update_state(dt, d, sig, xtra, *args)
\end{example}

\subsection{Example}
A complete example
\begin{example}
import numpy as np
from materials._material import Material
from core.io import Error1, log_error, log_message
try:
    import lib.elastic as elastic
except ImportError:
    elastic = None

class Elastic(Material):
    name = "elastic"
    param_names = ["K", "G"]
    def __init__(self):
        super(Elastic, self).__init__()

    def setup(self, params):
        if elastic is None:
            raise Error1("elastic model not imported")
        elastic.elastic_check(params, log_error, log_message)
        K, G, = params
        self.set_param_vals(params)
        self.bulk_modulus = K
        self.shear_modulus = G

    def update_state(self, dt, d, stress, xtra, *args):
        elastic.elastic_update_state(dt, self._param_vals,
                                     d, stress,
                                     log_error, log_message)
        return stress, xtra

    def jacobian(self, dt, d, stress, xtra, v):
        return self.constant_jacobian(v)
\end{example}

% ----------------------------------------------------------------------------- %
\section{Building and Linking Materials to \gmd{}}
\label{sec:usrbld}
\bldm{} builds the \gmd{} materials by searching the subdirectories of\\
\verb|$GMDROOT/materials/library| and the directories specified by the
\verb|$GMDMTLS| environment variables and building materials it finds.  It
does so by searching for a single file \texttt{makemf.py} in each directory.
\texttt{makemf.py} is responsible for building the materials and communicating
back to \bldm{}.

% ----------------------------------------------------------------------------- %
\subsection{Building User Materials}
User materials are built by the \texttt{makemf} function of the
\texttt{makemf.py} scripts

% --- makemf API
\begin{interface}
\textbf{makemf.makemf: Interface}
\end{interface}
\usage{blt, fld, skp = makemf(destd, fc, fio, materials=None, *args)}

\param{str dest}{path to directory to copy built shared object libraries (if
  any)}
\param{str fc}{path to fortran compiler}
\param{str fio}{path to the fortran IO routines}
\param{list materials}{list of materials to build.  if empty, build all}
\param{tuple args}{not used}

\param{tuple blt}{\texttt{(name, interface, mclass, parameters)}.
  \texttt{name} is the name of the material, \texttt{interface} the file path
  to the interface file, \texttt{mclass} the material model class name in
  \texttt{interface}, \texttt{parameters} an order list of parameter names}
\param{list fld}{list of names of materials that failed to build}
\param{list skp}{list of names of materials that were skipped}

% ----------------------------------------------------------------------------- %
\subsection{Building Materials with \fpy{}}
\label{sec:bldf2py}
Material models written in Fortran must compiled in to a Python shared object
library with \fpy{}. The function \texttt{utils.gmdf2py.f2yp} provides an
interface to \fpy{}.
\begin{interface}
\textbf{utils.gmdf2py.f2py: Interface}
\end{interface}
\usage{stat = f2py(name, source\us{}files, signature, fc, incd=None)}

\param{str name}{material model name.  will be used to set name of shared object
  library.}
\param{list source\us{}files}{list of absolute values of Fortran source files}
\param{str signature}{path to signature file}
\param{str fc}{path to Fortran compiler}
\param{str ind}{(optional) path to include directories}

\param{int stat}{returns 0 if successful, 1 otherwise}

Below is an example of using \texttt{gmdf2py.f2py}
\begin{example}
from utils.gmdf2py import f2py
def makemf(destd, fc, fio, materials=None, *args)
    ...
    stat = f2py(name, source_files, signature, fc, incd)
    if stat != 0:
        return [], [name], []

    shutil.move(name + ".so", os.path.join(destd, name + ".so"))
    return (name, filepath, mclass, parameters), [], []
\end{example}



% ----------------------------------------------------------------------------- %
\chapter{Regression Testing}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
